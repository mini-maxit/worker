// Code generated by generate_mocks.sh; DO NOT EDIT.

package mocks

import (
	reflect "reflect"

	executor "github.com/mini-maxit/worker/internal/stages/executor"
	packager "github.com/mini-maxit/worker/internal/stages/packager"
	languages "github.com/mini-maxit/worker/pkg/languages"
	messages "github.com/mini-maxit/worker/pkg/messages"
	solution "github.com/mini-maxit/worker/pkg/solution"
	amqp091 "github.com/rabbitmq/amqp091-go"
	gomock "go.uber.org/mock/gomock"
)

// Code generated by MockGen. DO NOT EDIT.
// Source: /Users/mateuszosik/repos/Testerka/worker/internal/rabbitmq/channel (interfaces: Channel)
//
// Generated by this command:
//
//	mockgen /Users/mateuszosik/repos/Testerka/worker/internal/rabbitmq/channel Channel
//

// Package mock_channel is a generated GoMock package.

// MockChannel is a mock of Channel interface.
type MockChannel struct {
	ctrl     *gomock.Controller
	recorder *MockChannelMockRecorder
	isgomock struct{}
}

// MockChannelMockRecorder is the mock recorder for MockChannel.
type MockChannelMockRecorder struct {
	mock *MockChannel
}

// NewMockChannel creates a new mock instance.
func NewMockChannel(ctrl *gomock.Controller) *MockChannel {
	mock := &MockChannel{ctrl: ctrl}
	mock.recorder = &MockChannelMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockChannel) EXPECT() *MockChannelMockRecorder {
	return m.recorder
}

// Consume mocks base method.
func (m *MockChannel) Consume(queue, consumer string, autoAck, exclusive, noLocal, noWait bool, args amqp091.Table) (<-chan amqp091.Delivery, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Consume", queue, consumer, autoAck, exclusive, noLocal, noWait, args)
	ret0, _ := ret[0].(<-chan amqp091.Delivery)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Consume indicates an expected call of Consume.
func (mr *MockChannelMockRecorder) Consume(queue, consumer, autoAck, exclusive, noLocal, noWait, args any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Consume", reflect.TypeOf((*MockChannel)(nil).Consume), queue, consumer, autoAck, exclusive, noLocal, noWait, args)
}

// Publish mocks base method.
func (m *MockChannel) Publish(exchange, key string, mandatory, immediate bool, msg amqp091.Publishing) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Publish", exchange, key, mandatory, immediate, msg)
	ret0, _ := ret[0].(error)
	return ret0
}

// Publish indicates an expected call of Publish.
func (mr *MockChannelMockRecorder) Publish(exchange, key, mandatory, immediate, msg any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockChannel)(nil).Publish), exchange, key, mandatory, immediate, msg)
}

// QueueDeclare mocks base method.
func (m *MockChannel) QueueDeclare(name string, durable, autoDelete, exclusive, noWait bool, args amqp091.Table) (amqp091.Queue, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueueDeclare", name, durable, autoDelete, exclusive, noWait, args)
	ret0, _ := ret[0].(amqp091.Queue)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueueDeclare indicates an expected call of QueueDeclare.
func (mr *MockChannelMockRecorder) QueueDeclare(name, durable, autoDelete, exclusive, noWait, args any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueueDeclare", reflect.TypeOf((*MockChannel)(nil).QueueDeclare), name, durable, autoDelete, exclusive, noWait, args)
}

// Code generated by MockGen. DO NOT EDIT.
// Source: /Users/mateuszosik/repos/Testerka/worker/internal/rabbitmq/responder (interfaces: Responder)
//
// Generated by this command:
//
//	mockgen /Users/mateuszosik/repos/Testerka/worker/internal/rabbitmq/responder Responder
//

// Package mock_responder is a generated GoMock package.

// MockResponder is a mock of Responder interface.
type MockResponder struct {
	ctrl     *gomock.Controller
	recorder *MockResponderMockRecorder
	isgomock struct{}
}

// MockResponderMockRecorder is the mock recorder for MockResponder.
type MockResponderMockRecorder struct {
	mock *MockResponder
}

// NewMockResponder creates a new mock instance.
func NewMockResponder(ctrl *gomock.Controller) *MockResponder {
	mock := &MockResponder{ctrl: ctrl}
	mock.recorder = &MockResponderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockResponder) EXPECT() *MockResponderMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockResponder) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockResponderMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockResponder)(nil).Close))
}

// Publish mocks base method.
func (m *MockResponder) Publish(queueName string, publishing amqp091.Publishing) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Publish", queueName, publishing)
	ret0, _ := ret[0].(error)
	return ret0
}

// Publish indicates an expected call of Publish.
func (mr *MockResponderMockRecorder) Publish(queueName, publishing any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockResponder)(nil).Publish), queueName, publishing)
}

// PublishErrorToResponseQueue mocks base method.
func (m *MockResponder) PublishErrorToResponseQueue(messageType, messageID, responseQueue string, err error) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "PublishErrorToResponseQueue", messageType, messageID, responseQueue, err)
}

// PublishErrorToResponseQueue indicates an expected call of PublishErrorToResponseQueue.
func (mr *MockResponderMockRecorder) PublishErrorToResponseQueue(messageType, messageID, responseQueue, err any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishErrorToResponseQueue", reflect.TypeOf((*MockResponder)(nil).PublishErrorToResponseQueue), messageType, messageID, responseQueue, err)
}

// PublishPayloadTaskRespond mocks base method.
func (m *MockResponder) PublishPayloadTaskRespond(messageType, messageID, responseQueue string, taskResult solution.Result) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PublishPayloadTaskRespond", messageType, messageID, responseQueue, taskResult)
	ret0, _ := ret[0].(error)
	return ret0
}

// PublishPayloadTaskRespond indicates an expected call of PublishPayloadTaskRespond.
func (mr *MockResponderMockRecorder) PublishPayloadTaskRespond(messageType, messageID, responseQueue, taskResult any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishPayloadTaskRespond", reflect.TypeOf((*MockResponder)(nil).PublishPayloadTaskRespond), messageType, messageID, responseQueue, taskResult)
}

// PublishSuccessHandshakeRespond mocks base method.
func (m *MockResponder) PublishSuccessHandshakeRespond(messageType, messageID, responseQueue string, languageSpecs []languages.LanguageSpec) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PublishSuccessHandshakeRespond", messageType, messageID, responseQueue, languageSpecs)
	ret0, _ := ret[0].(error)
	return ret0
}

// PublishSuccessHandshakeRespond indicates an expected call of PublishSuccessHandshakeRespond.
func (mr *MockResponderMockRecorder) PublishSuccessHandshakeRespond(messageType, messageID, responseQueue, languageSpecs any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishSuccessHandshakeRespond", reflect.TypeOf((*MockResponder)(nil).PublishSuccessHandshakeRespond), messageType, messageID, responseQueue, languageSpecs)
}

// PublishSuccessStatusRespond mocks base method.
func (m *MockResponder) PublishSuccessStatusRespond(messageType, messageID, responseQueue string, statusMap map[string]any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PublishSuccessStatusRespond", messageType, messageID, responseQueue, statusMap)
	ret0, _ := ret[0].(error)
	return ret0
}

// PublishSuccessStatusRespond indicates an expected call of PublishSuccessStatusRespond.
func (mr *MockResponderMockRecorder) PublishSuccessStatusRespond(messageType, messageID, responseQueue, statusMap any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishSuccessStatusRespond", reflect.TypeOf((*MockResponder)(nil).PublishSuccessStatusRespond), messageType, messageID, responseQueue, statusMap)
}

// Code generated by MockGen. DO NOT EDIT.
// Source: /Users/mateuszosik/repos/Testerka/worker/internal/scheduler (interfaces: Scheduler)
//
// Generated by this command:
//
//	mockgen /Users/mateuszosik/repos/Testerka/worker/internal/scheduler Scheduler
//

// Package mock_scheduler is a generated GoMock package.

// MockScheduler is a mock of Scheduler interface.
type MockScheduler struct {
	ctrl     *gomock.Controller
	recorder *MockSchedulerMockRecorder
	isgomock struct{}
}

// MockSchedulerMockRecorder is the mock recorder for MockScheduler.
type MockSchedulerMockRecorder struct {
	mock *MockScheduler
}

// NewMockScheduler creates a new mock instance.
func NewMockScheduler(ctrl *gomock.Controller) *MockScheduler {
	mock := &MockScheduler{ctrl: ctrl}
	mock.recorder = &MockSchedulerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockScheduler) EXPECT() *MockSchedulerMockRecorder {
	return m.recorder
}

// GetWorkersStatus mocks base method.
func (m *MockScheduler) GetWorkersStatus() map[string]any {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWorkersStatus")
	ret0, _ := ret[0].(map[string]any)
	return ret0
}

// GetWorkersStatus indicates an expected call of GetWorkersStatus.
func (mr *MockSchedulerMockRecorder) GetWorkersStatus() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkersStatus", reflect.TypeOf((*MockScheduler)(nil).GetWorkersStatus))
}

// ProcessTask mocks base method.
func (m *MockScheduler) ProcessTask(responseQueueName, messageID string, task *messages.TaskQueueMessage) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ProcessTask", responseQueueName, messageID, task)
	ret0, _ := ret[0].(error)
	return ret0
}

// ProcessTask indicates an expected call of ProcessTask.
func (mr *MockSchedulerMockRecorder) ProcessTask(responseQueueName, messageID, task any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProcessTask", reflect.TypeOf((*MockScheduler)(nil).ProcessTask), responseQueueName, messageID, task)
}

// Code generated by MockGen. DO NOT EDIT.
// Source: /Users/mateuszosik/repos/Testerka/worker/internal/stages/compiler (interfaces: Compiler)
//
// Generated by this command:
//
//	mockgen /Users/mateuszosik/repos/Testerka/worker/internal/stages/compiler Compiler
//

// Package mock_compiler is a generated GoMock package.

// MockCompiler is a mock of Compiler interface.
type MockCompiler struct {
	ctrl     *gomock.Controller
	recorder *MockCompilerMockRecorder
	isgomock struct{}
}

// MockCompilerMockRecorder is the mock recorder for MockCompiler.
type MockCompilerMockRecorder struct {
	mock *MockCompiler
}

// NewMockCompiler creates a new mock instance.
func NewMockCompiler(ctrl *gomock.Controller) *MockCompiler {
	mock := &MockCompiler{ctrl: ctrl}
	mock.recorder = &MockCompilerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCompiler) EXPECT() *MockCompilerMockRecorder {
	return m.recorder
}

// CompileSolutionIfNeeded mocks base method.
func (m *MockCompiler) CompileSolutionIfNeeded(langType languages.LanguageType, langVersion, sourceFilePath, outFilePath, compErrFilePath, messageID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CompileSolutionIfNeeded", langType, langVersion, sourceFilePath, outFilePath, compErrFilePath, messageID)
	ret0, _ := ret[0].(error)
	return ret0
}

// CompileSolutionIfNeeded indicates an expected call of CompileSolutionIfNeeded.
func (mr *MockCompilerMockRecorder) CompileSolutionIfNeeded(langType, langVersion, sourceFilePath, outFilePath, compErrFilePath, messageID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CompileSolutionIfNeeded", reflect.TypeOf((*MockCompiler)(nil).CompileSolutionIfNeeded), langType, langVersion, sourceFilePath, outFilePath, compErrFilePath, messageID)
}

// Code generated by MockGen. DO NOT EDIT.
// Source: /Users/mateuszosik/repos/Testerka/worker/internal/stages/executor (interfaces: Executor)
//
// Generated by this command:
//
//	mockgen /Users/mateuszosik/repos/Testerka/worker/internal/stages/executor Executor
//

// Package mock_executor is a generated GoMock package.

// MockExecutor is a mock of Executor interface.
type MockExecutor struct {
	ctrl     *gomock.Controller
	recorder *MockExecutorMockRecorder
	isgomock struct{}
}

// MockExecutorMockRecorder is the mock recorder for MockExecutor.
type MockExecutorMockRecorder struct {
	mock *MockExecutor
}

// NewMockExecutor creates a new mock instance.
func NewMockExecutor(ctrl *gomock.Controller) *MockExecutor {
	mock := &MockExecutor{ctrl: ctrl}
	mock.recorder = &MockExecutorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExecutor) EXPECT() *MockExecutorMockRecorder {
	return m.recorder
}

// ExecuteCommand mocks base method.
func (m *MockExecutor) ExecuteCommand(cfg executor.CommandConfig) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteCommand", cfg)
	ret0, _ := ret[0].(error)
	return ret0
}

// ExecuteCommand indicates an expected call of ExecuteCommand.
func (mr *MockExecutorMockRecorder) ExecuteCommand(cfg any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteCommand", reflect.TypeOf((*MockExecutor)(nil).ExecuteCommand), cfg)
}

// Code generated by MockGen. DO NOT EDIT.
// Source: /Users/mateuszosik/repos/Testerka/worker/internal/stages/packager (interfaces: Packager)
//
// Generated by this command:
//
//	mockgen /Users/mateuszosik/repos/Testerka/worker/internal/stages/packager Packager
//

// Package mock_packager is a generated GoMock package.

// MockPackager is a mock of Packager interface.
type MockPackager struct {
	ctrl     *gomock.Controller
	recorder *MockPackagerMockRecorder
	isgomock struct{}
}

// MockPackagerMockRecorder is the mock recorder for MockPackager.
type MockPackagerMockRecorder struct {
	mock *MockPackager
}

// NewMockPackager creates a new mock instance.
func NewMockPackager(ctrl *gomock.Controller) *MockPackager {
	mock := &MockPackager{ctrl: ctrl}
	mock.recorder = &MockPackagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPackager) EXPECT() *MockPackagerMockRecorder {
	return m.recorder
}

// PrepareSolutionPackage mocks base method.
func (m *MockPackager) PrepareSolutionPackage(taskQueueMessage *messages.TaskQueueMessage, msgID string) (*packager.TaskDirConfig, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PrepareSolutionPackage", taskQueueMessage, msgID)
	ret0, _ := ret[0].(*packager.TaskDirConfig)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PrepareSolutionPackage indicates an expected call of PrepareSolutionPackage.
func (mr *MockPackagerMockRecorder) PrepareSolutionPackage(taskQueueMessage, msgID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrepareSolutionPackage", reflect.TypeOf((*MockPackager)(nil).PrepareSolutionPackage), taskQueueMessage, msgID)
}

// SendSolutionPackage mocks base method.
func (m *MockPackager) SendSolutionPackage(dirConfig *packager.TaskDirConfig, testCases []messages.TestCase, hasCompilationErr bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendSolutionPackage", dirConfig, testCases, hasCompilationErr)
	ret0, _ := ret[0].(error)
	return ret0
}

// SendSolutionPackage indicates an expected call of SendSolutionPackage.
func (mr *MockPackagerMockRecorder) SendSolutionPackage(dirConfig, testCases, hasCompilationErr any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendSolutionPackage", reflect.TypeOf((*MockPackager)(nil).SendSolutionPackage), dirConfig, testCases, hasCompilationErr)
}

// Code generated by MockGen. DO NOT EDIT.
// Source: /Users/mateuszosik/repos/Testerka/worker/internal/stages/verifier (interfaces: Verifier)
//
// Generated by this command:
//
//	mockgen /Users/mateuszosik/repos/Testerka/worker/internal/stages/verifier Verifier
//

// Package mock_verifier is a generated GoMock package.

// MockVerifier is a mock of Verifier interface.
type MockVerifier struct {
	ctrl     *gomock.Controller
	recorder *MockVerifierMockRecorder
	isgomock struct{}
}

// MockVerifierMockRecorder is the mock recorder for MockVerifier.
type MockVerifierMockRecorder struct {
	mock *MockVerifier
}

// NewMockVerifier creates a new mock instance.
func NewMockVerifier(ctrl *gomock.Controller) *MockVerifier {
	mock := &MockVerifier{ctrl: ctrl}
	mock.recorder = &MockVerifierMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockVerifier) EXPECT() *MockVerifierMockRecorder {
	return m.recorder
}

// EvaluateAllTestCases mocks base method.
func (m *MockVerifier) EvaluateAllTestCases(dirConfig *packager.TaskDirConfig, testCases []messages.TestCase, messageID string) solution.Result {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EvaluateAllTestCases", dirConfig, testCases, messageID)
	ret0, _ := ret[0].(solution.Result)
	return ret0
}

// EvaluateAllTestCases indicates an expected call of EvaluateAllTestCases.
func (mr *MockVerifierMockRecorder) EvaluateAllTestCases(dirConfig, testCases, messageID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EvaluateAllTestCases", reflect.TypeOf((*MockVerifier)(nil).EvaluateAllTestCases), dirConfig, testCases, messageID)
}

// Code generated by MockGen. DO NOT EDIT.
// Source: /Users/mateuszosik/repos/Testerka/worker/internal/storage (interfaces: Storage)
//
// Generated by this command:
//
//	mockgen /Users/mateuszosik/repos/Testerka/worker/internal/storage Storage
//

// Package mock_storage is a generated GoMock package.

// MockStorage is a mock of Storage interface.
type MockStorage struct {
	ctrl     *gomock.Controller
	recorder *MockStorageMockRecorder
	isgomock struct{}
}

// MockStorageMockRecorder is the mock recorder for MockStorage.
type MockStorageMockRecorder struct {
	mock *MockStorage
}

// NewMockStorage creates a new mock instance.
func NewMockStorage(ctrl *gomock.Controller) *MockStorage {
	mock := &MockStorage{ctrl: ctrl}
	mock.recorder = &MockStorageMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStorage) EXPECT() *MockStorageMockRecorder {
	return m.recorder
}

// DownloadFile mocks base method.
func (m *MockStorage) DownloadFile(fileLocation messages.FileLocation, destPath string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DownloadFile", fileLocation, destPath)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DownloadFile indicates an expected call of DownloadFile.
func (mr *MockStorageMockRecorder) DownloadFile(fileLocation, destPath any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DownloadFile", reflect.TypeOf((*MockStorage)(nil).DownloadFile), fileLocation, destPath)
}

// UploadFile mocks base method.
func (m *MockStorage) UploadFile(filePath, bucket, objectKey string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UploadFile", filePath, bucket, objectKey)
	ret0, _ := ret[0].(error)
	return ret0
}

// UploadFile indicates an expected call of UploadFile.
func (mr *MockStorageMockRecorder) UploadFile(filePath, bucket, objectKey any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UploadFile", reflect.TypeOf((*MockStorage)(nil).UploadFile), filePath, bucket, objectKey)
}
