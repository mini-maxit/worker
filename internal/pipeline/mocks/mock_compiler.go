// Code generated by MockGen. DO NOT EDIT.
// Source: internal/stages/compiler/compiler.go
//
// Generated by this command:
//
//	mockgen -source=internal/stages/compiler/compiler.go -destination=internal/pipeline/mocks/mock_compiler.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	reflect "reflect"

	languages "github.com/mini-maxit/worker/pkg/languages"
	gomock "go.uber.org/mock/gomock"
)

// MockCompiler is a mock of Compiler interface.
type MockCompiler struct {
	ctrl     *gomock.Controller
	recorder *MockCompilerMockRecorder
	isgomock struct{}
}

// MockCompilerMockRecorder is the mock recorder for MockCompiler.
type MockCompilerMockRecorder struct {
	mock *MockCompiler
}

// NewMockCompiler creates a new mock instance.
func NewMockCompiler(ctrl *gomock.Controller) *MockCompiler {
	mock := &MockCompiler{ctrl: ctrl}
	mock.recorder = &MockCompilerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCompiler) EXPECT() *MockCompilerMockRecorder {
	return m.recorder
}

// CompileSolutionIfNeeded mocks base method.
func (m *MockCompiler) CompileSolutionIfNeeded(langType languages.LanguageType, langVersion, sourceFilePath, outFilePath, compErrFilePath, messageID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CompileSolutionIfNeeded", langType, langVersion, sourceFilePath, outFilePath, compErrFilePath, messageID)
	ret0, _ := ret[0].(error)
	return ret0
}

// CompileSolutionIfNeeded indicates an expected call of CompileSolutionIfNeeded.
func (mr *MockCompilerMockRecorder) CompileSolutionIfNeeded(langType, langVersion, sourceFilePath, outFilePath, compErrFilePath, messageID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CompileSolutionIfNeeded", reflect.TypeOf((*MockCompiler)(nil).CompileSolutionIfNeeded), langType, langVersion, sourceFilePath, outFilePath, compErrFilePath, messageID)
}

// MockLanguageCompiler is a mock of LanguageCompiler interface.
type MockLanguageCompiler struct {
	ctrl     *gomock.Controller
	recorder *MockLanguageCompilerMockRecorder
	isgomock struct{}
}

// MockLanguageCompilerMockRecorder is the mock recorder for MockLanguageCompiler.
type MockLanguageCompilerMockRecorder struct {
	mock *MockLanguageCompiler
}

// NewMockLanguageCompiler creates a new mock instance.
func NewMockLanguageCompiler(ctrl *gomock.Controller) *MockLanguageCompiler {
	mock := &MockLanguageCompiler{ctrl: ctrl}
	mock.recorder = &MockLanguageCompilerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLanguageCompiler) EXPECT() *MockLanguageCompilerMockRecorder {
	return m.recorder
}

// Compile mocks base method.
func (m *MockLanguageCompiler) Compile(sourceFilePath, outFilePath, compErrFilePath, messageID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Compile", sourceFilePath, outFilePath, compErrFilePath, messageID)
	ret0, _ := ret[0].(error)
	return ret0
}

// Compile indicates an expected call of Compile.
func (mr *MockLanguageCompilerMockRecorder) Compile(sourceFilePath, outFilePath, compErrFilePath, messageID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Compile", reflect.TypeOf((*MockLanguageCompiler)(nil).Compile), sourceFilePath, outFilePath, compErrFilePath, messageID)
}

// RequiresCompilation mocks base method.
func (m *MockLanguageCompiler) RequiresCompilation() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RequiresCompilation")
	ret0, _ := ret[0].(bool)
	return ret0
}

// RequiresCompilation indicates an expected call of RequiresCompilation.
func (mr *MockLanguageCompilerMockRecorder) RequiresCompilation() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RequiresCompilation", reflect.TypeOf((*MockLanguageCompiler)(nil).RequiresCompilation))
}
